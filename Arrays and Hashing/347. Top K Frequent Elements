Approach 1 — Naive (Sorting)

Idea: Count → store pairs → sort → take top K
	•	Use a HashMap to store frequencies.
	•	Convert entries into a List<int[]> (where int[0] = element, int[1] = frequency).
	•	Sort the list by frequency in descending order using a comparator.
	•	Take the first K items.

Time: O(n log n)
Space: O(n)

⸻

Approach 2 — Max-Heap (PriorityQueue)

Idea: Count & push all elements into a max-heap → pop top K
	•	Sort the input array.
	•	Count frequencies in a single scan.
	•	Push each (element, freq) pair into a max-heap that prioritizes highest freq.
	•	Pop K times.

Time: O(n log n)
Space: O(n)

⸻

Approach 3 — Min-Heap of Size K (Optimized)

Idea: Maintain only top K elements in a min-heap
	•	Count frequencies in a HashMap.
	•	Use a min-heap of size at most K where each entry is (freq, element).
	•	For each map entry, push into the heap.
	•	If heap size > K → pop the smallest element (least frequent).
	•	Remaining K elements in heap = top K frequent.

Time: O(n log k)
Space: O(n + k)

⸻

Approach 4 — Bucket Sort (Best Overall)

Idea: Frequency can be at most n → use buckets indexed by frequency
	•	Count frequencies in a HashMap.
	•	Create an array/list of buckets of size n + 1.
	•	Bucket index = frequency → each bucket stores elements with that freq.
	•	Traverse buckets from highest freq to lowest until K elements collected.

Time: O(n)
Space: O(n)